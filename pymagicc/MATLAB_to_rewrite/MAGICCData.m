classdef MAGICCData < handle
    properties
        full_path_source_file
        full_path_file2write

        Date = ''
        Description = ''
        Source = ''
        Contact = ''
        Compiled_by = ''

        Notes = {}

        data_table
    end

    properties (SetAccess = private)
        descriptor_fields = {...
            'Date' 'Description' 'Source' 'Contact' ...
            'Compiled_by'...
        };
        descriptor_strings

        data_table_metadata_columns = {'Variable' 'TODO' 'Unit' 'Region'}
        data_table_numeric_columns = {'Year' 'Value'}
        data_table_cell_columns = {'Notes'}
    end

    properties (Access = protected)
        ArgParser = inputParser
        
        MAGICC_emissions_units_csv
        MAGICC_concentrations_units_csv
        MAGICC_unit_conversion_csv
        
        MAGICC_units_emissions_table
        MAGICC_units_concentrations_table
        MAGICC_unit_conversion_table
    end

    methods
        function self = MAGICCData
            self.data_table = self.return_empty_data_table;
            definitions_path = fullfile(...
                object_oriented_simcap.Utils.return_path_to_directory_containing_this_file,...
                '..','definitions'...
            );
            self.MAGICC_emissions_units_csv = fullfile(...
                definitions_path,...
                'MAGICC_emissions_units.csv'...
            );
            self.MAGICC_concentrations_units_csv = fullfile(...
                definitions_path,...
                'MAGICC_concentrations_units.csv'...
            );
            self.MAGICC_unit_conversion_csv = fullfile(...
                definitions_path,...
                'MAGICC_unit_conversion.csv'...
            );
        end
        
        function set.Notes(self,value)
            self.Notes = object_oriented_simcap.Utils.return_as_cellstr(...
                value...
            ); 
        end

        function descriptor_strings = get.descriptor_strings(self)
            descriptor_strings = cellfun(...
                @(x) self.return_descriptor_string_from_descriptor_field(x),...
                self.descriptor_fields,...
                'UniformOutput',false...
            );
        end
        function descriptor_string = return_descriptor_string_from_descriptor_field(self,descriptor_field)
             descriptor_string = [replace(descriptor_field,'_',' ') ': '];
        end

        function plot(self,varargin)
            self.parse_plot_inputs(varargin{:})
            self.make_plot
        end
        function plot_file(self,file_name,varargin)
            self.parse_plot_file_inputs(file_name,varargin{:})
            self.read_MAGICC_data_file(self.ArgParser.Results.file_name)
            self.make_plot
        end
        function plot_files(self,varargin)
            narginchk(2,inf)
            self.parse_plot_files_inputs(varargin{:})
            Handler = object_oriented_simcap.MAGICCDataHandler;
            MAGICCData_array = Handler.return_MAGICCData_array_from_MAGICC_datafiles(...
                'paths_to_search',self.ArgParser.Results.paths_to_search,...
                'regexp_searches',self.ArgParser.Results.regexp_searches...
            );
            FilePlotter = object_oriented_simcap.Plotters.MAGICCDataPlotterManyObjects;
            FilePlotter.plot_objects_with_config(...
                MAGICCData_array,...
                self.ArgParser.Results.plot_config...
            )
        end
        function plot_files_with_generic_descriptors(self,varargin)
            narginchk(2,inf)
            self.parse_plot_files_inputs(varargin{:})
            Handler = object_oriented_simcap.MAGICCDataHandler;
            MAGICCData_array = Handler.return_MAGICCData_array_generic_descrptrs_from_MAGICC_datafiles(...
                'paths_to_search',self.ArgParser.Results.paths_to_search,...
                'regexp_searches',self.ArgParser.Results.regexp_searches...
            );
            FilePlotter = object_oriented_simcap.Plotters.MAGICCDataPlotterManyObjects;
            FilePlotter.plot_objects_with_config(...
                MAGICCData_array,...
                self.ArgParser.Results.plot_config...
            )
        end
        function plot_files_with_generic_descriptors_and_totals(self,varargin)
            narginchk(2,inf)
            self.parse_plot_files_inputs(varargin{:})
            Handler = object_oriented_simcap.MAGICCDataHandler;
            MAGICCData_array = Handler.return_MAGICCData_array_generic_rgns_ttls_from_MAGICC_datafiles(...
                'paths_to_search',self.ArgParser.Results.paths_to_search,...
                'regexp_searches',self.ArgParser.Results.regexp_searches...
            );
            FilePlotter = object_oriented_simcap.Plotters.MAGICCDataPlotterManyObjects;
            FilePlotter.plot_objects_with_config(...
                MAGICCData_array,...
                self.ArgParser.Results.plot_config...
            )
        end

        function value = return_variable_region_year_value(self,variable,region,year)
             value = self.data_table.Value(...
                 strcmp(self.data_table.Region,region)...
                 & strcmp(self.data_table.Variable,variable)...
                 & self.data_table.Year == year ...
             );
        end

        function read_MAGICC_data_file(self,MAGICC_data_file)
            data_file_reader = self.determine_and_return_file_reader_from_file_full_path(...
                MAGICC_data_file...
            );
            try
                data_file_reader.read_MAGICC_data_file(MAGICC_data_file)
            catch ME
                error_msg = [...
                    'I can''t read ' newline MAGICC_data_file newline...
                    getReport(ME)...
                ];
                MyException = MException(...
                    'MAGICCDataReaderError:unable_to_read_file',...
                    error_msg...
                );
                throw(MyException);end
            % push end up for code coverage
            self.set_fields_from_data_field_of_object(data_file_reader)
        end
        function read_MAGICC_data_file_with_generic_descriptors(self,MAGICC_data_file)
            % this reads MAGICC data files with generic descriptors and
            % also makes all variables reflect FORTRAN standard i.e. makes
            % everything upper case as FORTRAN is case insensitive and
            % removes all hyphens from variable names
            self.read_MAGICC_data_file(MAGICC_data_file)
            self.convert_regions_to_generic_regions
            self.convert_to_MAGICC_variables
        end
        function read_MAGICC_data_file_with_generic_descriptors_with_totals(self,MAGICC_data_file)
            self.read_MAGICC_data_file_with_generic_descriptors(MAGICC_data_file)
            self.make_total_variables
        end

        function write_MAGICC_data_file(self)
            data_file_writer = self.determine_and_return_file_writer_from_file_full_path(...
                self.full_path_file2write...
            );
            data_file_writer.data = self;
            data_file_writer.write_MAGICC_data_file
        end

        function generate_files_from_generator_config_csv(self,config_csv)
            data_file_generator = object_oriented_simcap.Generators.MAGICCDataFileGenerator;
            data_file_generator.generate_files_from_generator_config_csv(config_csv);
        end
        function read_config_struct = return_config_struct_from_dfile_config_csv(self,config_csv)
            data_file_generator = object_oriented_simcap.Generators.MAGICCDataFileGenerator;
            read_config_struct = data_file_generator.return_config_struct_from_dfile_config_csv(...
                config_csv...
            );
        end

        function generate_files_from_config_struct(self,config)
            data_file_generator = object_oriented_simcap.Generators.MAGICCDataFileGenerator;
            data_file_generator.generate_files_from_config_struct(config)
        end

        function interpolate_data_table(self,varargin)
            Interpolater = object_oriented_simcap.Interpolaters.MAGICCDataInterpolater;
            self = Interpolater.return_interpolated_MAGICCData(...
                self,...
                varargin{:}...
            );
        end
        
        function add_note_to_data_table_rows(self,note,rows2addto)
            if ~islogical(rows2addto)
                error(...
                    'MAGICCDataError:rows2addto_must_be_a_logical',...
                    'The second input argument must be a logical vector'...
                );
            end
            if length(rows2addto) ~= height(self.data_table)
                error(...
                    'MAGICCDataError:rows2addto_must_be_same_height_as_data_table',...
                    ['The second input argument must be the same length as '...
                     'the data table']...
                ); 
            end
            self.data_table.Notes(rows2addto) = cellfun(...
                @(x) [x {note}],...
                self.data_table.Notes(rows2addto),...
                'UniformOutput',false...
            );
        end
        
        function convert_to_MAGICC_units(self)
            unique_var_units = unique(...
                self.data_table(:,{'Variable' 'Unit'})...
            ); 
            for i=1:height(unique_var_units)
                variable = unique_var_units.Variable{i};
                unit = unique_var_units.Unit{i};
                if ~self.is_valid_MAGICC_variable_unit_pair(variable,unit)
                    self.convert_variable_unit_pair_to_MAGICC_unit(...
                        variable,...
                        unit...
                    )
                end
            end
        end
        
        function check_regional_breakdowns(self)
            self.prepare_data_table_for_breakdown_check
            for variable = unique(self.data_table.Variable)'
                if self.regional_breakdown_provided_for_variable(variable{1})
                    self.check_regional_breakdown_for_variable(variable{1}); 
                end
            end
        end
        
        function convert_to_MAGICC_variables(self)
            variable_mapping = {...
                'OtherCO2' 'CO2B';...
                'FossilCO2' 'CO2I';...
            };
            for variable = unique(self.data_table.Variable)'
                if ismember(variable{1},variable_mapping(:,1))
                    variable_mapping_matching_idx = strcmp(...
                        variable_mapping(:,1),...
                        variable{1}...
                    );
                    new_variable_name = variable_mapping{...
                        variable_mapping_matching_idx,2 ...
                    };
                else
                    new_variable_name = upper(...
                        replace(variable{1},'-','')...
                    );
                end
                if ~strcmp(variable{1},new_variable_name)
                    variable_rows_to_rename = strcmp(...
                        self.data_table.Variable,...
                        variable{1}...
                    );
                    self.data_table.Variable = replace(...
                        self.data_table.Variable,...
                        variable{1},new_variable_name...
                    );
                    self.add_note_to_data_table_rows(...
                        [variable{1} ' renamed as ' new_variable_name...
                         ' to make it MAGICC7 compliant'],...
                        variable_rows_to_rename...
                    )
                end
            end
        end
    end

    methods (Access = private)
        function empty_data_table = return_empty_data_table(self)
            for metadata_column = self.data_table_metadata_columns
                data_table_struct.(metadata_column{1}) = {''};
            end
            for numeric_column = self.data_table_numeric_columns
                data_table_struct.(numeric_column{1}) = NaN;
            end
            for cell_column = self.data_table_cell_columns
                data_table_struct.(cell_column{1}) = {{}};
            end
            empty_data_table = struct2table(data_table_struct);
        end

        
        function DataFileReader = determine_and_return_file_reader_from_file_full_path(self,file_full_path)
            file_name = self.extract_file_name_from_full_path(file_full_path);
            if self.is_HIST_EMIS_IN_file(file_name)
                DataFileReader = object_oriented_simcap.Readers.HIST_EMIS_INFileReader;
            elseif self.is_SCEN_file(file_name)
                DataFileReader = object_oriented_simcap.Readers.SCENFileReader;
            elseif self.is_SCEN7_file(file_name)
                DataFileReader = object_oriented_simcap.Readers.SCEN7FileReader;
            elseif self.is_CONC_IN_file(file_name)
                DataFileReader = object_oriented_simcap.Readers.CONC_INFileReader;
            elseif self.is_INVERSEEMIS_OUT_file(file_name)
                DataFileReader = object_oriented_simcap.Readers.INVERSEEMIS_OUTFileReader;
            elseif self.is_SECTOR_file(file_name)
                DataFileReader = object_oriented_simcap.Readers.SECTORFileReader;
            else
                error_msg = [...
                    'I don''t know which reader to use for ' newline...
                    file_full_path...
                ];
                error(...
                    'MAGICCDataError:unrecognised_file_type',...
                    error_msg...
                )
            end
        end
        function DataFileWriter = determine_and_return_file_writer_from_file_full_path(self,file_full_path)
            file_name = self.extract_file_name_from_full_path(file_full_path);
            if self.is_HIST_EMIS_IN_file(file_name)
                DataFileWriter = object_oriented_simcap.Writers.HIST_EMIS_INFileWriter;
            elseif self.is_SCEN7_file(file_name)
                DataFileWriter = object_oriented_simcap.Writers.SCEN7FileWriter;
            elseif self.is_CONC_IN_file(file_name)
                DataFileWriter = object_oriented_simcap.Writers.CONC_INFileWriter;
            elseif self.is_SECTOR_file(file_name)
                DataFileWriter = object_oriented_simcap.Writers.SECTORFileWriter;
            else
                error_msg = [...
                    'I don''t know which writer to use for ' newline...
                    file_full_path...
                ];
                error(...
                    'MAGICCDataError:unrecognised_file_type',...
                    error_msg...
                )
            end
        end
        
        function file_name = extract_file_name_from_full_path(self,full_path)
            [file_path,file_base,file_ext] = fileparts(full_path);
            file_name = [file_base file_ext];
        end
        
        function return_val = is_HIST_EMIS_IN_file(self,file_name)
            return_val = object_oriented_simcap.Utils.regexp_matches_entire_string(...
                file_name,...
                '^HIST.*\_EMIS\.IN$'...
            );
        end
        function return_val = is_SCEN_file(self,file_name)
            return_val = object_oriented_simcap.Utils.regexp_matches_entire_string(...
                file_name,...
                '^.*\.SCEN$'...
            );
        end
        function return_val = is_SCEN7_file(self,file_name)
            return_val = object_oriented_simcap.Utils.regexp_matches_entire_string(...
                file_name,...
                '^.*\.SCEN7$'...
            );
        end
        function return_val = is_CONC_IN_file(self,file_name)
            return_val = object_oriented_simcap.Utils.regexp_matches_entire_string(...
                file_name,...
                '^.*\_.*CONC.*\.IN$'...
            );
        end
        function return_val = is_INVERSEEMIS_OUT_file(self,file_name)
            return_val = object_oriented_simcap.Utils.regexp_matches_entire_string(...
                file_name,...
                '^INVERSEEMIS\_.*\.OUT$'...
            );
        end
        function return_val = is_SECTOR_file(self,file_name)
            return_val = endsWith(file_name,'.SECTOR');
        end

        
        function set_fields_from_data_field_of_object(self,object_to_copy_from)
            for prop = properties(object_to_copy_from.data)'
                self.(prop{1}) = object_to_copy_from.data.(prop{1});
            end
        end

        
        function make_plot(self)
            plotter = object_oriented_simcap.Plotters.MAGICCDataPlotter;
            plotter.plot_MAGICCDataObj(...
                self,...
                self.ArgParser.Results.plot_config...
            );
        end
        
        function parse_plot_files_inputs(self,varargin)
            Handler = object_oriented_simcap.MAGICCDataHandler;
            self.ArgParser = Handler.get_ArgParser;
            self.add_plot_inputs_to_ArgParser
            self.ArgParser.parse(varargin{:})
        end
        function parse_plot_file_inputs(self,file_name,varargin)
            self.ArgParser = inputParser;
            self.add_plot_inputs_to_ArgParser;
            self.ArgParser.addRequired(...
                'file_name',...
                @(x) ischar(x) || isstring(x)...
            )
            self.ArgParser.parse(file_name,varargin{:})
        end
        function parse_plot_inputs(self,varargin)
            self.ArgParser = inputParser;
            self.add_plot_inputs_to_ArgParser;
            self.ArgParser.parse(varargin{:})
        end
        function add_plot_inputs_to_ArgParser(self)
            self.ArgParser.addParameter('plot_config',struct(),@isstruct)
        end

        
        function convert_regions_to_generic_regions(self)
            region_mapping = {...
                'R5OECD' 'ROECD';...
                'R5REF' 'RREF';...
                'R5MAF' 'RMAF';...
                'R5LAM' 'RLAM';...
                'R5ASIA' 'RASIA';...
                'R6OECD90' 'ROECD';...
                'R6REF' 'RREF';...
                'R6MAF' 'RMAF';...
                'R6LAM' 'RLAM';...
                'R6ASIA' 'RASIA';...
            };
            for i=1:size(region_mapping,1)
                old_region_name = region_mapping{i,1};
                matching_region_idx = strcmp(...
                    self.data_table.Region,...
                    old_region_name...
                );
                if any(matching_region_idx)
                    new_region_name = region_mapping{i,2};
                    self.data_table.Region = replace(...
                        self.data_table.Region,...
                        old_region_name,new_region_name...
                    );
                    self.add_note_to_data_table_rows(...
                        [old_region_name ' renamed as ' new_region_name],...
                        matching_region_idx...
                    )
                end
            end
        end
        
        function make_total_variables(self)
            unique_variable_regions = unique(...
                self.data_table(:,{'Variable' 'Region'})...
            );
            for i=1:height(unique_variable_regions)
                if ~endsWith(unique_variable_regions.Variable{i},'I')
                    % as long as we make totals from all fossil variables
                    % we'll cover everything so can continue
                    continue;end
                % push end up for code coverage
                region_rows = strcmp(...
                    self.data_table.Region,...
                    unique_variable_regions.Region{i}...
                );

                fossil_variable_rows = strcmp(...
                    self.data_table.Variable,...
                    unique_variable_regions.Variable{i}...
                );
                fossil_data_rows = fossil_variable_rows & region_rows;

                land_variable_rows = strcmp(...
                    self.data_table.Variable,...
                    [unique_variable_regions.Variable{i}(1:end-1) 'B']...
                );
                land_data_rows = land_variable_rows & region_rows;

                total_table = self.data_table(fossil_data_rows,:);
                total_table.Variable = repmat(...
                    {unique_variable_regions.Variable{i}(1:end-1)},...
                    height(total_table),1 ...
                );
                total_table.Value = self.data_table.Value(fossil_data_rows)...
                                    + self.data_table.Value(land_data_rows);
                note_to_write = [...
                    'Sum of '...
                    unique_variable_regions.Variable{i} ' and '...
                    unique_variable_regions.Variable{i}(1:end-1) 'B'...
                ];
                total_table.Notes = repmat(...
                    {{note_to_write}},...
                    height(total_table),1 ...
                );
                self.data_table = [...
                    self.data_table;...
                    total_table...
                ];
            end
        end
        
        
        function return_val = is_valid_MAGICC_variable_unit_pair(self,variable,unit)
            MAGICC_unit = self.return_MAGICC_unit_for_variable_unit_pair(variable,unit);
            return_val = strcmp(unit,MAGICC_unit);
        end
        function convert_variable_unit_pair_to_MAGICC_unit(self,variable,unit)
            MAGICC_unit = self.return_MAGICC_unit_for_variable_unit_pair(variable,unit);
            [conversion_factor_str,conversion_note] = self.return_conversion_factor_str_and_note_from_unit_to_unit_for_var(...
                unit,...
                MAGICC_unit,...
                variable...
            );
            rows_to_convert = strcmp(self.data_table.Variable,variable)...
                              & strcmp(self.data_table.Unit,unit);
            self.data_table.Value(rows_to_convert) = self.data_table.Value(rows_to_convert)...
                                                     * str2num(conversion_factor_str);
            self.data_table.Unit(rows_to_convert) = {MAGICC_unit};
            self.add_note_to_data_table_rows(...
                conversion_note,...
                rows_to_convert...
            )
        end
        
        function MAGICC_unit = return_MAGICC_unit_for_variable_unit_pair(self,variable,unit)
            if startsWith(unit,'pp')
                MAGICC_unit = self.return_MAGICC_concentrations_unit_for_variable(variable);
            else
                MAGICC_unit = self.return_MAGICC_emissions_unit_for_variable(variable);
            end
        end
        function MAGICC_unit = return_MAGICC_emissions_unit_for_variable(self,variable)
            units_emms_table = self.get_MAGICC_units_emissions_table;
            MAGICC_variables = units_emms_table.MAGICC_variable;
            var_row = strcmp(MAGICC_variables,variable)...
                      | strcmp(MAGICC_variables,variable(1:end-1));
            if ~any(var_row)
                error(...
                    'MAGICCDataError:unrecognised_emissions_variable',...
                    [variable ' is not a recognised MAGICC emissions variable so it '...
                     'can''t be converted to MAGICC units.']...
                )
            end
            MAGICC_unit = units_emms_table.Emissions_units{var_row};
        end
        function MAGICC_unit = return_MAGICC_concentrations_unit_for_variable(self,variable)
            units_concs_table = self.get_MAGICC_units_concentrations_table;
            MAGICC_variables = units_concs_table.MAGICC_variable;
            var_row = strcmp(MAGICC_variables,variable);
            if ~any(var_row)
                error(...
                    'MAGICCDataError:unrecognised_concentration_variable',...
                    [variable ' is not a recognised MAGICC concentrations variable so it '...
                     'can''t be converted to MAGICC units.']...
                )
            end
            MAGICC_unit = units_concs_table.Concentration_units{var_row};
        end
        
        function [cnvrsn_fctr_str,cnvrsn_nt] = return_conversion_factor_str_and_note_from_unit_to_unit_for_var(self,old_unit,new_unit,variable)
            try
                [cnvrsn_fctr_str,cnvrsn_nt] = self.return_cnvrsn_factor_str_note_from_unt_to_unt_for_var_rename(...
                    old_unit,...
                    new_unit,...
                    variable...
                );
                return
            catch ME
                self.check_is_unrecognised_conversion_error(ME)
            end
            try
                [cnvrsn_fctr_str,cnvrsn_nt] = self.return_cnvrsn_factor_str_note_from_unt_to_unt_for_var_no_assume(...
                    old_unit,...
                    new_unit...
                );
                return
            catch ME
                self.check_is_unrecognised_conversion_error(ME)
            end
            try
                [cnvrsn_fctr_str,cnvrsn_nt] = self.return_cnvrsn_factor_str_note_from_unt_to_unt_for_var_assume(...
                    old_unit,...
                    new_unit,...
                    variable...
                );
                return
            catch ME
                self.check_is_unrecognised_conversion_error(ME)
            end
            error_msg = [...
                'I tried converting ' old_unit ' to ' new_unit ' by '...
                'including/removing the variable name, ' variable ', and '...
                'still did not know how to convert.'...
            ];
            error(...
                'MAGICCDataError:unrecognised_unit_conversion',...
                error_msg...
            )
        end
        function [cnvrsn_fctr_str,cnvrsn_nt] = return_cnvrsn_factor_str_note_from_unt_to_unt_for_var_rename(self,old_unit,new_unit,variable)
            conversions_to_try = self.return_conversions_to_try_for_old_unit_variable(...
                old_unit,...
                variable...
            );
            if ismember(new_unit,conversions_to_try)
                cnvrsn_fctr_str = '1';
                cnvrsn_nt = [...
                    'Assumed ' old_unit ' is the same as ' new_unit...
                ];
            else
                error(...
                    'MAGICCDataError:unrecognised_unit_conversion',...
                    'I don''t think a simple renaming is valid'...
                )
            end
        end
        function [cnvrsn_fctr_str,cnvrsn_nt] = return_cnvrsn_factor_str_note_from_unt_to_unt_for_var_no_assume(self,old_unit,new_unit,variable)
            cnvrsn_fctr_str = self.return_conversion_factor_str_from_unit_to_unit(...
                old_unit,...
                new_unit...
            );
            cnvrsn_nt = [...
                'Converted from ' old_unit ' to ' new_unit...
                ' by applying a conversion factor of ' cnvrsn_fctr_str......
            ];
        end
        function [cnvrsn_fctr_str,cnvrsn_nt] = return_cnvrsn_factor_str_note_from_unt_to_unt_for_var_assume(self,old_unit,new_unit,variable)
            conversions_to_try = self.return_conversions_to_try_for_old_unit_variable(...
                old_unit,...
                variable...
            );
            for conversion_to_try = conversions_to_try
                try
                    cnvrsn_fctr_str = self.return_conversion_factor_str_from_unit_to_unit(...
                        conversion_to_try{1},...
                        new_unit...
                    );
                    cnvrsn_nt = [...
                        'Converted from ' old_unit ' to ' ...
                        new_unit ' by applying a conversion factor of '...
                        cnvrsn_fctr_str ' under the assumption that ' ...
                        old_unit ' means ' conversion_to_try{1}...
                    ];
                    return
                catch ME
                    self.check_is_unrecognised_conversion_error(ME)
                end
            end
            
            simple_conversions_to_try = {...
                replace(old_unit,variable,'') replace(new_unit,variable,'');...
                replace(old_unit,variable(1:end-1),'') replace(new_unit,variable(1:end-1),'');...
            };
            for i = 1:size(simple_conversions_to_try,1)
                try
                    cnvrsn_fctr_str = self.return_conversion_factor_str_from_unit_to_unit(...
                        simple_conversions_to_try{i,1},...
                        simple_conversions_to_try{i,2}...
                    );
                    cnvrsn_nt = [...
                        'Converted from ' old_unit ' to ' new_unit...
                        ' by applying a conversion factor of ' cnvrsn_fctr_str......
                    ];
                    return
                catch ME
                    self.check_is_unrecognised_conversion_error(ME)
                end
            end
            
            error(...
                'MAGICCDataError:unrecognised_unit_conversion',...
                ['I couldn''t find a valid conversion even after trying '...
                 'all the sensible assumptions I could think of.']...
            )
        end
        function conversions_to_try = return_conversions_to_try_for_old_unit_variable(self,old_unit,variable)
            stripped_old_unit = replace(...
                old_unit,...
                {variable variable(1:end-1) '/' 'yr' ' '},...
                ''...
            );
            conversions_to_try = {...
                [old_unit variable]...
                [old_unit variable(1:end-1)]...
                stripped_old_unit...
                [stripped_old_unit variable]...
                [stripped_old_unit variable(1:end-1)]...
            };
        end
        function conversion_factor_str = return_conversion_factor_str_from_unit_to_unit(self,old_unit,new_unit)
            conversion_factor_table = self.get_MAGICC_unit_conversion_table;
            conversion_factor_row = strcmp(conversion_factor_table.Old_unit,old_unit)...
                                    & strcmp(conversion_factor_table.New_unit,new_unit);
            if sum(conversion_factor_row) == 1
                conversion_factor_str = conversion_factor_table.Conversion_factor_string{...
                    conversion_factor_row...
                };
                return
            end
            conversion_factor_row = strcmp(conversion_factor_table.Old_unit,new_unit)...
                                    & strcmp(conversion_factor_table.New_unit,old_unit);
            if sum(conversion_factor_row) == 1
                inverse_conversion_factor_str = conversion_factor_table.Conversion_factor_string{...
                    conversion_factor_row...
                };
                conversion_factor_str = [...
                    '1/(' inverse_conversion_factor_str ')'...
                ];
                return
            end
            
            
            error(...
                'MAGICCDataError:unrecognised_unit_conversion',...
                ['I don''t know how to convert ' old_unit ' to '...
                 new_unit]...
            )

        end
        function check_is_unrecognised_conversion_error(self,ME)
            if ~strcmp(ME.identifier,'MAGICCDataError:unrecognised_unit_conversion')
                rethrow(ME)
            end
        end
        
        function MAGICC_units_emissions_table = get_MAGICC_units_emissions_table(self)
            if isempty(self.MAGICC_units_emissions_table)
                self.MAGICC_units_emissions_table = readtable(...
                    self.MAGICC_emissions_units_csv...
                );
            end
            MAGICC_units_emissions_table = self.MAGICC_units_emissions_table;
        end
        function MAGICC_units_concentrations_table = get_MAGICC_units_concentrations_table(self)
            if isempty(self.MAGICC_units_concentrations_table)
                self.MAGICC_units_concentrations_table = readtable(...
                    self.MAGICC_concentrations_units_csv...
                );
            end
            MAGICC_units_concentrations_table = self.MAGICC_units_concentrations_table;
        end
        function MAGICC_unit_conversion_table = get_MAGICC_unit_conversion_table(self)
            if isempty(self.MAGICC_unit_conversion_table)
                self.MAGICC_unit_conversion_table = readtable(...
                    self.MAGICC_unit_conversion_csv,...
                    'HeaderLines',0,...
                    'ReadVariableNames',true...
                );
            end
            MAGICC_unit_conversion_table = self.MAGICC_unit_conversion_table;
        end
        
        function prepare_data_table_for_breakdown_check(self)
            self.data_table = sortrows(...
                self.data_table,...
                {'Variable' 'Region' 'Year'}...
            );
        end
        function return_val = regional_breakdown_provided_for_variable(self,variable)
            variable_regions = unique(self.data_table.Region(...
                strcmp(self.data_table.Variable,variable)...
            ));
            return_val = ismember('WORLD',variable_regions)...
                         && length(variable_regions) > 1;
        end
        function check_regional_breakdown_for_variable(self,variable)
            variable_rows = strcmp(self.data_table.Variable,variable);
            WORLD_rows = strcmp(self.data_table.Region,'WORLD');
            
            world_values = self.data_table.Value(variable_rows & WORLD_rows);
            non_world_values = self.data_table.Value(variable_rows & ~WORLD_rows);
            non_world_sum = sum(...
                reshape(non_world_values,length(world_values),[]),...
                2 ...
            );
        
            sanity_check_text = [...
                'Sanity check passed: WORLD is the sum of '...
                strjoin(unique(self.data_table.Region(~WORLD_rows)),', ')...
            ];
            if ~all(abs((world_values - non_world_sum)./world_values) < 10^-3 ...
                    | abs(world_values - non_world_sum) < 10^-7)
                sanity_check_text = replace(...
                    sanity_check_text,...
                    {'is'     'Sanity check passed'},...
                    {'is not' 'Warning'}...
                );
                warning(...
                    'MAGICCDataWarning:inconsistent_regional_breakdown',...
                    replace(sanity_check_text,'WORLD',[variable ' WORLD'])...
                )
            end
            self.add_note_to_data_table_rows(...
                sanity_check_text,...
                variable_rows & WORLD_rows...
             )
        end
    end
end
